
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module MiniBot(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SDRAM //////////
	DRAM_ADDR,
	DRAM_BA,
	DRAM_CAS_N,
	DRAM_CKE,
	DRAM_CLK,
	DRAM_CS_N,
	DRAM_DQ,
	DRAM_DQM,
	DRAM_RAS_N,
	DRAM_WE_N,

	//////////// EPCS //////////
	EPCS_ASDO,
	EPCS_DATA0,
	EPCS_DCLK,
	EPCS_NCSO,

	//////////// Accelerometer and EEPROM //////////
	G_SENSOR_CS_N,
	G_SENSOR_INT,
	I2C_SCLK,
	I2C_SDAT,

	//////////// ADC //////////
	ADC_CS_N,
	ADC_SADDR,
	ADC_SCLK,
	ADC_SDAT,

	//////////// 2x13 GPIO Header //////////
	GPIO_2,
	GPIO_2_IN,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	GPIO_0_PI,
	GPIO_0_PI_IN,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	GPIO_1,
	GPIO_1_IN 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// SW //////////
input 		     [3:0]		SW;

//////////// SDRAM //////////
output		    [12:0]		DRAM_ADDR;
output		     [1:0]		DRAM_BA;
output		          		DRAM_CAS_N;
output		          		DRAM_CKE;
output		          		DRAM_CLK;
output		          		DRAM_CS_N;
inout 		    [15:0]		DRAM_DQ;
output		     [1:0]		DRAM_DQM;
output		          		DRAM_RAS_N;
output		          		DRAM_WE_N;

//////////// EPCS //////////
output		          		EPCS_ASDO;
input 		          		EPCS_DATA0;
output		          		EPCS_DCLK;
output		          		EPCS_NCSO;

//////////// Accelerometer and EEPROM //////////
output		          		G_SENSOR_CS_N;
input 		          		G_SENSOR_INT;
output		          		I2C_SCLK;
inout 		          		I2C_SDAT;

//////////// ADC //////////
output		          		ADC_CS_N;
output		          		ADC_SADDR;
output		          		ADC_SCLK;
input 		          		ADC_SDAT;

//////////// 2x13 GPIO Header //////////
inout 		    [12:0]		GPIO_2;
input 		     [2:0]		GPIO_2_IN;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout 		    [33:0]		GPIO_0_PI;
input 		     [1:0]		GPIO_0_PI_IN;

//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
inout 		    [33:0]		GPIO_1;
input 		     [1:0]		GPIO_1_IN;

//=======================================================
//  SPI
//=======================================================
		logic 			spi_clk, spi_cs, spi_mosi, spi_miso, cs_spi;
		logic [31:0]  spi_data, DataAdrM;

	spi_slave spi_slave_instance(
		.SPI_CLK    (spi_clk),
		.SPI_CS     (spi_cs),
		.SPI_MOSI   (spi_mosi),
		.SPI_MISO   (spi_miso),
		.Data_WE    (cs_spi), 	// to be changed with WE chosen => MemWriteM & cs_spi
		.Data_Addr  (DataAdrM),            
		.Data_Write (DataToPI),
		.Data_Read  (spi_data),
		.Clk        (clk)
	);
	
	assign spi_clk  		= GPIO_0_PI[11];	// SCLK = pin 16 = GPIO_11
	assign spi_cs   		= GPIO_0_PI[9];	// CE0  = pin 14 = GPIO_9
	assign spi_mosi     	= GPIO_0_PI[15];	// MOSI = pin 20 = GPIO_15
	
	assign GPIO_0_PI[13] = spi_cs ? 1'bz : spi_miso;  // MISO = pin 18 = GPIO_13 


//=======================================================
//  MyMiniBot
//=======================================================

	// decalration of all variables //
	logic clk;
	logic reset; 
	logic [7:0] led_reg;
	logic key1, key0;
	//logic MemWrite;
	logic [2:0] thread;
	
	// Declaration of WriteData
	logic [31:0] WriteData, WriteData2, WriteData3, WriteData4,WriteData5,WriteData6,WriteData7,WriteData8,WriteData9;
	
	logic [31:0] DataToPI;
	
	logic [31:0] posBeacon,negBeacon,nTikz, posBeaconPremier, count_laser_a,count_laser_b;
	logic  cs_dmem, cs_led, cs_spi_wr, cs_spi_rd;
	
	
	logic [31:0] count_mot_left, count_mot_left_b, count_mot_right, count_mot_right_b, premier, premier_posEdge;

	logic mot_left_cod_a,mot_left_cod_b;
	logic mot_right_cod_a,mot_right_cod_b;
	logic laser_cod_a,laser_cod_b;
	logic laser_sync,laser_signal;
	logic uart_tx,uart_rx,uart_dir;
	logic current_a, previous_a, current_b, previous_b;
	logic CountS1Enable,CountS1Reset,PosedgeDetected, nTickzMotorEnable, PosReset;
	logic [31:0] new_count_mot_right, CountS1;
	
//=======================================================
//  Assignment of variables 
//=======================================================
		
	assign clk = CLOCK_50;
	assign reset = GPIO_0_PI[1];
	
	// keys
	assign key0=~KEY[0];
	assign key1=~KEY[1];
	
	// switches
	assign sw0= SW[0]; 
  	assign sw1= SW[1]; 
	assign sw2= SW[2]; 
	assign sw3= SW[3]; 
	
	// Corresponding between signals and GPIO's
	/*assign mot_left_cod_a =GPIO_1[0];
	assign mot_left_cod_b = GPIO_1_IN[0];
	assign mot_right_cod_a =GPIO_1[2];
	assign mot_right_cod_b = GPIO_1[1];
	assign laser_cod_a =GPIO_1[4] ;
	assign laser_cod_b = GPIO_1[5];
	assign laser_sync = GPIO_1[7];
	assign laser_signal =  GPIO_1[8];*/
	assign uart_tx =  GPIO_1[26];
	assign uart_rx =  GPIO_1[24];
	assign uart_dir =GPIO_1[22];

//=======================================================
//  Anti Glitch 
//=======================================================
	antiGlitch antiGlitchLaserSig (.clk(clk), .reset(key0), .in(GPIO_1[8]), .out(laser_signal));
	antiGlitch antiGlitchLaserSync (.clk(clk), .reset(key0), .in(GPIO_1[7]), .out(laser_sync));
	antiGlitch antiGlitchLaserMotorA (.clk(clk), .reset(key0), .in(GPIO_1[4]), .out(laser_cod_a));
	antiGlitch antiGlitchLaserMotorB (.clk(clk), .reset(key0), .in(GPIO_1[5]), .out(laser_cod_b));
	
	antiGlitch antiGlitchRightMotorA (.clk(clk), .reset(key0), .in(GPIO_1[2]), .out(mot_right_cod_a));
	antiGlitch antiGlitchRightMotorB (.clk(clk), .reset(key0), .in(GPIO_1[1]), .out(mot_right_cod_b));
	antiGlitch antiGlitchLeftMotorA (.clk(clk), .reset(key0), .in(GPIO_1[0]), .out(mot_left_cod_a));
	antiGlitch antiGlitchLeftMotorB (.clk(clk), .reset(key0), .in(GPIO_1_IN[0]), .out(mot_left_cod_b));
	
	// MOTOR COUNTERS
	always_ff @(posedge mot_left_cod_a, posedge key0) 
	begin
		if(key0) count_mot_left<= 32'b0;
		else 
			begin 
			if (mot_left_cod_b) 
			count_mot_left<= count_mot_left+32'b1;
			else count_mot_left<= count_mot_left-32'b1;
			end
	end


	always_ff @(posedge mot_right_cod_a, posedge key0) 
	begin
		if(key0) count_mot_right<= 32'b0;
		else 
			begin  
			if (mot_right_cod_b) count_mot_right<= count_mot_right-32'b1;
			else count_mot_right<= count_mot_right+32'b1;
			end
	end

	// LASER MOTOR COUNTERS
	always_ff @(posedge laser_sync, posedge laser_cod_a) 
	begin
		if(laser_sync) count_laser_a<= 32'd0;
		else 
			begin  
				if (laser_cod_a) count_laser_a<= count_laser_a+32'b1;
			end
	end
	
	always_ff @(posedge laser_sync)
	begin
		nTikz <= count_laser_a;
	end
	
	always_ff @(posedge laser_signal)
	begin
		if(premier)
			posBeaconPremier <= count_laser_a;
		else
		posBeacon <= count_laser_a;
		
	end
	
	always_ff @(posedge laser_signal,posedge laser_sync)
	begin
		if(laser_sync) premier <= 0;
		else
			begin 
			premier<= premier+32'b1;
			end
	end
	
	always_ff @(negedge laser_signal)
	begin
		negBeacon <= count_laser_a;
	end
	
	
	always_ff @(posedge laser_sync, posedge laser_cod_b) 
	begin
		if(laser_sync)begin count_laser_b<= 32'b0; premier_posEdge <= premier; end 
		else 
			begin  
				if (laser_cod_b) count_laser_b<= count_laser_b+32'b1;
			end
	end
		
	
	assign WriteData= {24'b0,laser_sync,laser_signal,laser_cod_a,laser_cod_b,mot_right_cod_a,mot_right_cod_b,mot_left_cod_a,mot_left_cod_b};
	assign WriteData2=count_mot_left;
	assign WriteData3=count_mot_right;
	assign WriteData4=count_laser_a;
	assign WriteData5=count_laser_b;
	assign WriteData6 = posBeacon;
	assign WriteData7 = negBeacon;
	assign WriteData8 = nTikz; // alpha/2 -> angle entre extrémité et milieu beacon
	assign WriteData9 =  new_count_mot_right;
	// LED logic	 
	assign LED = WriteData2;

always_ff @(posedge clk)
		begin 	
		led_reg<=laser_signal;
		end

	// SPI output Register
	 always_ff @(posedge clk)
	begin 
		if (sw0)
		begin
		cs_spi = 1;
		DataToPI<= WriteData9;
		DataAdrM = 32'h0000_0000;
		end
		
		else if (sw1)
		begin
			case (thread)
			3'b000:
				begin 
					if (spi_data ==32'h0000_0005) 
						begin
						cs_spi = 1;
						DataToPI<= 0;
						DataAdrM = 32'h0000_0004;
						thread = 3'b001; 
						end
					
					else 
						begin 	
						cs_spi = 1;
						DataToPI<= WriteData2;
						DataAdrM = 32'h0000_0004;
						thread = 3'b001; 
						end 
					end
			3'b001: 
				begin
					if (spi_data ==32'h0000_0005) 
						begin
						cs_spi = 1;
						DataToPI<= 0;
						DataAdrM = 32'h0000_0008;
						thread = 3'b010; 
						end
					else 
						begin
						cs_spi = 1;
						DataToPI<= WriteData3;
						DataAdrM = 32'h0000_0008;
						thread = 3'b010; 
						end 
				end 	
				
			3'b010:
				begin 
						cs_spi = 1;
						DataAdrM = 32'h0000_000C;
						DataToPI<=WriteData4;
						thread=3'b011;
				end
		
			3'b011:
				begin 
						cs_spi = 1;
						DataAdrM = 32'h0000_0010;
						DataToPI<=WriteData5;
						thread=3'b100;
				end
			3'b100:
				begin
						cs_spi = laser_sync;
						DataAdrM = 32'h0000_0014;
						DataToPI<=WriteData6; //posBeacon
						thread=3'b101;
						
				end
			3'b101:
				begin
						cs_spi = laser_sync;
						DataAdrM = 32'h0000_0018;
						DataToPI<=WriteData7; //negBeacon
						thread=3'b110;
						
				end
			3'b110:
				begin
						cs_spi = 1;
						DataAdrM = 32'h0000_001C;
						DataToPI<=WriteData8; //nTikz
						thread=3'b000;
						
				end
			default:	begin
						cs_spi = 0;
						DataToPI<= 32'b0;
						DataAdrM = 32'bx;
						thread=3'b000;
					end
	endcase
end
end



endmodule
